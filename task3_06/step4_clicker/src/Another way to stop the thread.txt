// Объемный, много кода, нашел в интернете! (работает!)
// Для прерывания и последующего запуска потока

private static volatile boolean running = true;
private volatile boolean paused = false;
private final Object pauseLock = new Object();

while (running) {
            synchronized (pauseLock) {
                if (!running) { // возможно, что-то изменилось во время ожидания
                    // синхронизация при pauseLock
                    break;
                }
                if (paused) {
                    try {
                        pauseLock.wait(); // приведет к блокировке этого потока до тех пор, пока
                        // другой поток вызывает функцию pauseLock.notifyAll()
                        // Обратите внимание, что вызов функции wait() приведет
                        // к снятию синхронизированной блокировки, которую этот
                        // поток удерживает на паузе, поэтому другой поток
                        // может получить блокировку для вызова функции notifyAll()
                        // (ссылка с пояснением под этим кодом)
                    } catch (InterruptedException ex) {
                        break;
                    }
                    if (!running) { // running, возможно, изменился с тех пор, как мы остановились
                        break;
                    }
                }
            }
            // ваш код
    }
    //}
    //---------------------------------------------------------------------------------------------
    public void stop() {
        running = false;
        // возможно, вы также захотите прервать (interrupt()) поток, который
        // запускает этот исполняемый файл, или, возможно, вызвать:
        resume();
        // чтобы разблокировать
    }
    //---------------------------------------------------------------------------------------------
    public void pause() {
        // возможно, вы захотите создать исключение IllegalStateException, если !running
        paused = true;
    }
    //---------------------------------------------------------------------------------------------
    public void resume() {
        synchronized (pauseLock) {
            paused = false;
            pauseLock.notifyAll(); // Разблокирует поток
        }
    }
    //---------------------------------------------------------------------------------------------
    @Override
    public void mouseEntered(MouseEvent e) {
        // Добавить в слушатель при наведении на компонент
        if (e.getComponent().getClass().equals(Oval.class)) {
            clicker.pause();
        } else {
            clicker.resume();
        }
    }
    //---------------------------------------------------------------------------------------------